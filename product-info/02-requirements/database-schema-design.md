# Database Schema Design for TubeIntel Pro

## Table of Contents

1. [Entity-Relationship Diagram (ER Diagram)](#entity-relationship-diagram)
2. [Table Structures](#table-structures)
3. [Key Management](#key-management)
4. [Indexing Strategy](#indexing-strategy)
5. [Database Normalization](#database-normalization)
6. [Query Patterns](#query-patterns)
7. [Migration Strategy](#migration-strategy)
8. [Data Integrity Rules](#data-integrity-rules)
9. [Performance Optimization](#performance-optimization)
10. [Database Security](#database-security)
11. [ORM Integration](#orm-integration)

---

## Entity-Relationship Diagram (ER Diagram)

### Complete Entity Relationship Map

1. **User**: Represents a user of the application.
2. **Channel**: Represents a YouTube channel being tracked.
3. **Video**: Represents videos associated with channels.
4. **Competitor**: Represents competitor channels being tracked.
5. **Alert**: Represents real-time VPH alerts for videos.
6. **Transcript**: Holds transcripts for videos.
7. **Metadata**: Holds metadata for videos.
8. **Automation**: Represents automation workflows for exporting data.
9. **Insight**: AI-Powered viral insights generated for content.

### Cardinality Notations

- **User** to **Channel**: One-to-Many
- **Channel** to **Video**: One-to-Many
- **Channel** to **Competitor**: Many-to-Many
- **Video** to **Alert**: One-to-Many
- **Video** to **Transcript**: One-to-One
- **Video** to **Metadata**: One-to-One
- **User** to **Automation**: One-to-Many
- **Video** to **Insight**: One-to-Many

### Entity Inheritance Relationships

- Not applicable as entities represent distinct concepts with no hierarchical relationships.

### Aggregate Relationships

- **Channel** aggregates **Video**, **Transcript**, **Metadata**, **Insight**, and **Alert**.

### Domain Boundaries

- **Analytics Domain**: User, Channel, Video, Competitor, Alert
- **Content Domain**: Transcript, Metadata, Insight
- **Automation Domain**: Automation

---

## Table Structures

### User Table

- **Columns**:
  - `user_id` SERIAL PRIMARY KEY
  - `email` VARCHAR(255) UNIQUE NOT NULL
  - `password_hash` VARCHAR(255) NOT NULL
  - `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  - `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP

- **Constraints**:
  - `email` must be unique to prevent duplicate user accounts.

### Channel Table

- **Columns**:
  - `channel_id` SERIAL PRIMARY KEY
  - `user_id` INT REFERENCES User(user_id) ON DELETE CASCADE
  - `youtube_id` VARCHAR(50) UNIQUE NOT NULL
  - `name` VARCHAR(255) NOT NULL
  - `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP

- **Constraints**:
  - `youtube_id` must be unique to ensure each channel is distinct.

### Video Table

- **Columns**:
  - `video_id` SERIAL PRIMARY KEY
  - `channel_id` INT REFERENCES Channel(channel_id) ON DELETE CASCADE
  - `youtube_id` VARCHAR(50) UNIQUE NOT NULL
  - `title` VARCHAR(255) NOT NULL
  - `published_at` TIMESTAMP NOT NULL
  - `vph` INT CHECK (vph >= 0)

- **Constraints**:
  - `youtube_id` must be unique; `vph` (views per hour) should be non-negative.

### Competitor Table

- **Columns**:
  - `competitor_id` SERIAL PRIMARY KEY
  - `channel_id` INT REFERENCES Channel(channel_id) ON DELETE CASCADE
  - `youtube_id` VARCHAR(50) UNIQUE NOT NULL
  - `name` VARCHAR(255) NOT NULL

- **Constraints**:
  - Unique `youtube_id` for each competitor channel.

### Alert Table

- **Columns**:
  - `alert_id` SERIAL PRIMARY KEY
  - `video_id` INT REFERENCES Video(video_id) ON DELETE CASCADE
  - `type` VARCHAR(50) NOT NULL
  - `message` TEXT NOT NULL
  - `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP

- **Constraints**:
  - Alerts are linked to videos and contain a type and message.

### Transcript Table

- **Columns**:
  - `transcript_id` SERIAL PRIMARY KEY
  - `video_id` INT REFERENCES Video(video_id) UNIQUE ON DELETE CASCADE
  - `content` TEXT NOT NULL

- **Constraints**:
  - Each video can have one transcript.

### Metadata Table

- **Columns**:
  - `metadata_id` SERIAL PRIMARY KEY
  - `video_id` INT REFERENCES Video(video_id) UNIQUE ON DELETE CASCADE
  - `data` JSONB NOT NULL

- **Constraints**:
  - Metadata stored as JSONB for flexibility.

### Automation Table

- **Columns**:
  - `automation_id` SERIAL PRIMARY KEY
  - `user_id` INT REFERENCES User(user_id) ON DELETE CASCADE
  - `name` VARCHAR(255) NOT NULL
  - `config` JSONB NOT NULL

- **Constraints**:
  - Each user can have multiple automation configs.

### Insight Table

- **Columns**:
  - `insight_id` SERIAL PRIMARY KEY
  - `video_id` INT REFERENCES Video(video_id) ON DELETE CASCADE
  - `description` TEXT NOT NULL
  - `ai_evaluation` JSONB NOT NULL

- **Constraints**:
  - Insights generated by AI stored in JSONB format.

---

## Key Management

### Primary Key Selection

- **Surrogate Keys**: Used for all tables for simplicity and efficiency.
- **Natural Keys**: Not used due to potential changes in natural data.

### Composite Key Implementation

- **Competitor Table**: Composite key of `channel_id` and `youtube_id` to prevent duplicate competitor entries for a channel.

### Foreign Key Behaviors

- **ON DELETE CASCADE**: Ensures that deleting a user/channel/video automatically deletes related records.

### Circular Reference Handling

- Avoided by design; no direct circular dependencies exist.

### Self-Referential Relationship Patterns

- Not applicable as no self-referencing entities are present.

### Junction Table Design

- **ChannelCompetitors**: For many-to-many relationships between channels and competitors.

---

## Indexing Strategy

### B-tree Index Recommendations

- High-cardinality columns: `email`, `youtube_id`.

### Partial Indexes

- Frequently filtered queries: `video_id` where `published_at` is within a certain range.

### Multi-Column Index Design

- Example: `(channel_id, youtube_id)` for `Competitor` table.

### GIN Indexes

- JSONB fields: `data` in `Metadata`, `ai_evaluation` in `Insight`.

### Index Maintenance Recommendations

- Regularly REINDEX tables with heavy updates.

### Covering Indexes

- Queries frequently accessing specific columns: Use covering indexes for optimization.

### Index Impact Analysis

- Balance between read optimization and write performance.

---

## Database Normalization

### First Normal Form (1NF)

- All tables have atomic values and unique rows.

### Second Normal Form (2NF)

- All non-key attributes fully depend on the primary key.

### Third Normal Form (3NF)

- No transitive dependencies exist among non-key attributes.

### Boyce-Codd Normal Form (BCNF)

- All tables adhere to BCNF principles.

### Strategic Denormalization

- JSONB in `Metadata` and `Insight` to handle complex, flexible data structures.

### Horizontal vs. Vertical Partitioning

- Consider horizontal partitioning for `Video` table for performance scaling.

---

## Query Patterns

### Complex Join Operations

- Joins across `User`, `Channel`, `Video` for comprehensive data retrieval.

### Recursive Query Patterns

- Not required in current schema, no hierarchical data.

### Materialized View Strategies

- Frequently accessed analytics reports can be stored as materialized views.

### Common Table Expressions (CTEs)

- Use CTEs for breaking down complex queries for readability.

### Window Function Usage

- Ranking and analytics queries on `Video` viewership trends.

### Analytical Query Optimization

- Use indexes and partitioning for optimizing analytics queries.

### Temporal Query Patterns

- Timestamped data to analyze trends over time.

### Full-Text Search Implementation

- GIN indexes on textual content for efficient full-text search.

---

## Migration Strategy

### Schema Evolution Principles

- Use version-controlled migrations for schema changes.

### Zero-Downtime Migration Techniques

- Use techniques like adding columns without locking tables.

### Version Control Integration

- Migrations managed using Git and CI/CD pipelines.

### Rollback Mechanisms

- Ensure safe rollback paths for all migrations.

### Data Migration Approaches

- Handle data transformations in application-level scripts.

### Schema Validation Pre-Deployment

- Validate schema changes in staging environments.

### Database Migration Testing Strategies

- Comprehensive testing of migrations in isolated environments.

---

## Data Integrity Rules

### Domain Constraints

- Specific CHECK constraints on fields like `vph`.

### Referential Integrity Enforcement

- Foreign keys with cascading actions maintain integrity.

### Business Rule Implementation

- Implemented via constraints and application logic.

### Triggers for Complex Integrity Rules

- Triggers can be added for auditing or complex integrity checks.

### Stored Procedures for Encapsulated Logic

- Use stored procedures for critical business logic.

### Validation at Database Level vs. Application Level

- Balance between database constraints and application-level validation.

---

## Performance Optimization

### Table Partitioning Strategies

- Horizontal partitioning for `Video` based on `published_at`.

### Connection Pooling Configuration

- Use connection pooling for efficient resource management.

### Query Plan Analysis Approaches

- Regular EXPLAIN ANALYZE for query performance insights.

### Statement-Level vs. Row-Level Security

- Optimize security policies for minimal performance impact.

### VACUUM and ANALYZE Scheduling

- Regular scheduling to maintain database health.

### Read Replica Configuration

- Configure read replicas for scaling read operations.

### Caching Layer Integration

- Implement caching for frequently accessed data.

### Horizontal Scaling Considerations

- Design for scalability with distributed systems.

---

## Database Security

### Role-Based Access Control (RBAC) Design

- Define roles with specific permissions for data access.

### Column-Level Security Implementation

- Sensitive columns have restricted access based on roles.

### Row-Level Security (RLS) Policies

- Implement RLS for multi-tenant data models.

### Data Encryption Strategies

- Encrypt sensitive data at rest and in transit.

### Audit Logging Implementation

- Implement audit logging for critical data modifications.

### Sensitive Data Handling

- Mask or encrypt sensitive data fields.

---

## ORM Integration

### Prisma Schema Declarations

- Define models and relationships using Prisma schema.

### Model Relationship Definitions

- Explicitly define one-to-many and many-to-many relationships.

### Middleware Integration

- Implement Prisma middleware for logging and validation.

### Type-Safe Query Building

- Utilize Prisma's type-safe query building capabilities.

### Transaction Management

- Use transactions for atomic operations.

### Soft Delete Implementation

- Implement soft deletes using boolean flags.

### Optimistic Locking Strategies

- Use versioning fields for optimistic concurrency control.

---

This comprehensive database schema design provides a robust foundation for TubeIntel Pro, ensuring scalability, performance, and security while integrating seamlessly with Prisma ORM for efficient application development.